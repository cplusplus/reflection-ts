%!TEX root = ts.tex

\rSec0[language.support]{Language support library}

\pnum
Add a new subclause \ref{reflect} titled "\textbf{Static reflection}" as follows:

\setcounter{section}{10}

\rSec1[reflect]{Static reflection}
\rSec2[reflect.general]{In general}

\begin{std.txt}\color{addclr}

\pnum
As laid out in \ref{dcl.type.reflexpr}, compile-time constant metadata,
describing various aspects of a program (static reflection data), can be
accessed through meta-object types.  The actual metadata is obtained by
instantiating templates constituting the interface of the meta-object types.
These templates are collectively referred to as \emph{meta-object operations}.

\pnum
Meta-object types satisfy different concepts (\ref{reflect.concepts}) depending on the type
they reflect (\ref{dcl.type.reflexpr}).  These concepts can also be used for
meta-object type classification.  They form a generalization-specialization
hierarchy, with \tcode{reflect::Object} being the common generalization for all
meta-object types.  Unary operations and type transformations used to query
static reflection data associated with these concepts are described in
\ref{reflect.ops}.
  
\end{std.txt}

\rSec2[reflect.synopsis]{Header \tcode{<experimental/reflect>} synopsis}

\begin{std.txt}\color{addclr}
\begin{codeblock}
namespace std {
namespace experimental {
namespace reflect {
inline namespace v1 {

// \ref{reflect.concepts} Concepts for meta-object types
template <class T>
concept bool Object = @\seebelow@;
template <class T>
concept bool ObjectSequence = @\seebelow@; // refines Object
template <class T>
concept bool TemplateParameterScope = @\seebelow@; // refines Scope
template <class T>
concept bool Named = @\seebelow@;          // refines Object
template <class T>
concept bool Alias = @\seebelow@;          // refines Named and ScopeMember
template <class T>
concept bool RecordMember = @\seebelow@;   // refines ScopeMember
template <class T>
concept bool Enumerator = @\seebelow@;     // refines Constant
template <class T>
concept bool Variable = @\seebelow@;       // refines Typed and ScopeMember
template <class T>
concept bool ScopeMember = @\seebelow@;    // refines Named
template <class T>
concept bool Typed = @\seebelow@;          // refines Object
template <class T>
concept bool Namespace = @\seebelow@;      // refines Named and Scope
template <class T>
concept bool GlobalScope = @\seebelow@;    // refines Namespace
template <class T>
concept bool Class = @\seebelow@;          // refines Record
template <class T>
concept bool Enum = @\seebelow@;           // refines Type, Scope, and ScopeMember
template <class T>
concept bool Record = @\seebelow@;         // refines Type, Scope, and ScopeMember
template <class T>
concept bool Scope = @\seebelow@;          // refines Object
template <class T>
concept bool Type = @\seebelow@;           // refines Named
template <class T>
concept bool Constant = @\seebelow@;       // refines Typed and ScopeMember
template <class T>
concept bool Base = @\seebelow@;           // refines Object
template <class T>
concept bool FunctionParameter = @\seebelow@; // refines Typed and ScopeMember
template <class T>
concept bool Callable = @\seebelow@;       // refines Scope and ScopeMember
template <class T>
concept bool Expression = @\seebelow@;     // refines Object
template <class T>
concept bool ParenthesizedExpression = @\seebelow@;  // refines Expression
template <class T>
concept bool FunctionCallExpression = @\seebelow@;   // refines Expression
template <class T>
concept bool FunctionalTypeConversion = @\seebelow@; // refines Expression
template <class T>
concept bool Function = @\seebelow@;       // refines Typed and Callable
template <class T>
concept bool MemberFunction = @\seebelow@; // refines RecordMember and Function
template <class T>
concept bool SpecialMemberFunction = @\seebelow@; // refines RecordMember
template <class T>
concept bool Constructor = @\seebelow@;    // refines Callable and RecordMember
template <class T>
concept bool Destructor = @\seebelow@;     // refines Callable and SpecialMemberFunction
template <class T>
concept bool Operator = @\seebelow@;       // refines Function
template <class T>
concept bool ConversionOperator = @\seebelow@; // refines MemberFunction and Operator
template <class T>
concept bool Lambda = @\seebelow@;         // refines Type and Scope
template <class T>
concept bool LambdaCapture = @\seebelow@;  // refines Variable


// \ref{reflect.ops} Meta-object operations
// Multi-concept operations
template <Object T> struct is_public;
template <Object T> struct is_protected;
template <Object T> struct is_private;
template <Object T> struct is_constexpr;
template <Object T> struct is_static;
template <Object T> struct is_final;
template <Object T> struct is_explicit;
template <Object T> struct is_inline;
template <Object T> struct is_virtual;
template <Object T> struct is_pure_virtual;
template <Object T> struct get_pointer;

template <class T>
requires RecordMember<T> || Base<T>
  constexpr auto is_public_v = is_public<T>::value;
template <class T>
requires RecordMember<T> || Base<T>
  constexpr auto is_protected_v = is_protected<T>::value;
template <class T>
requires RecordMember<T> || Base<T>
  constexpr auto is_private_v = is_private<T>::value;
template <class T>
requires Variable<T> || Callable<T>
   constexpr auto is_constexpr_v = is_constexpr<T>::value;
template <class T>
requires Variable<T> || MemberFunction<T>
   constexpr auto is_static_v = is_static<T>::value;
template <class T>
requires Class<T> || MemberFunction<T>
   constexpr auto is_final_v = is_final<T>::value;
template <class T>
requires Constructor<T> || ConversionOperator<T>
   constexpr auto is_explicit_v = is_explicit<T>::value;
template <class T>
requires Namespace<T> || Callable<T>
   constexpr auto is_inline_v = is_inline<T>::value;
template <class T>
requires Base<T> || MemberFunction<T> || Destructor<T>
   constexpr auto is_virtual_v = is_virtual<T>::value;
template <class T>
requires MemberFunction<T> || Destructor<T>
   constexpr auto is_pure_virtual_v = is_pure_virtual<T>::value;
template <class T>
requires Variable<T> || Function<T>
   constexpr auto get_pointer_v = get_pointer<T>::value;

// \ref{reflect.ops.object} Object operations
template <Object T1, Object T2> struct reflects_same;
template <Object T> struct get_source_line;
template <Object T> struct get_source_column;
template <Object T> struct get_source_file_name;

template <Object T1, Object T2>
  constexpr auto reflects_same_v = reflects_same<T1, T2>::value;
template <class T>
  constexpr auto get_source_line_v = get_source_line<T>::value;
template <class T>
  constexpr auto get_source_column_v = get_source_column<T>::value;
template <class T>
  constexpr auto get_source_file_name_v = get_source_file_name<T>::value;

// \ref{reflect.ops.objseq} ObjectSequence operations
template <ObjectSequence T> struct get_size;
template <size_t I, ObjectSequence T> struct get_element;
template <template <class...> class Tpl, ObjectSequence T>
  struct unpack_sequence;

template <ObjectSequence T>
  constexpr auto get_size_v = get_size<T>::value;
template <size_t I, ObjectSequence T>
  using get_element_t = typename get_element<I, T>::type;
template <template <class...> class Tpl, ObjectSequence T>
  using unpack_sequence_t = typename unpack_sequence<Tpl, T>::type;

// \ref{reflect.ops.named} Named operations
template <Named T> struct is_unnamed;
template <Named T> struct get_name;
template <Named T> struct get_display_name;

template <Named T>
  constexpr auto is_unnamed_v = is_unnamed<T>::value;
template <Named T>
  constexpr auto get_name_v = get_name<T>::value;
template <Named T>
  constexpr auto get_display_name_v = get_display_name<T>::value;

// \ref{reflect.ops.alias} Alias operations
template <Alias T> struct get_aliased;

template <Alias T>
  using get_aliased_t = typename get_aliased<T>::type;

// \ref{reflect.ops.type} Type operations
template <Typed T> struct get_type;
template <Type T> struct get_reflected_type;
template <Type T> struct is_enum;
template <Class T> struct uses_class_key;
template <Class T> struct uses_struct_key;
template <Type T> struct is_union;

template <Typed T>
  using get_type_t = typename get_type<T>::type;
template <Type T>
  using get_reflected_type_t = typename get_reflected_type<T>::type;
template <Type T>
  constexpr auto is_enum_v = is_enum<T>::value;
template <Class T>
  constexpr auto uses_class_key_v = uses_class_key<T>::value;
template <Class T>
  constexpr auto uses_struct_key_v = uses_struct_key<T>::value;
template <Type T>
  constexpr auto is_union_v = is_union<T>::value;

// \ref{reflect.ops.member} Member operations
template <ScopeMember T> struct get_scope;
template <RecordMember T> struct is_public<T>;
template <RecordMember T> struct is_protected<T>;
template <RecordMember T> struct is_private<T>;

template <ScopeMember T>
  using get_scope_t = typename get_scope<T>::type;

// \ref{reflect.ops.record} Record operations
template <Record T> struct get_public_data_members;
template <Record T> struct get_accessible_data_members;
template <Record T> struct get_data_members;
template <Record T> struct get_public_member_functions;
template <Record T> struct get_accessible_member_functions;
template <Record T> struct get_member_functions;
template <Record T> struct get_public_member_types;
template <Record T> struct get_accessible_member_types;
template <Record T> struct get_member_types;
template <Record T> struct get_constructors;
template <Record T> struct get_destructor;
template <Record T> struct get_operators;
template <Class T> struct get_public_base_classes;
template <Class T> struct get_accessible_base_classes;
template <Class T> struct get_base_classes;
template <Class T> struct is_final<T>;

template <Record T>
  using get_public_data_members_t = typename get_public_data_members<T>::type;
template <Record T>
  using get_accessible_data_members_t = typename get_accessible_data_members<T>::type;
template <Record T>
  using get_data_members_t = typename get_data_members<T>::type;
template <Record T>
  using get_public_member_functions_t = typename get_public_member_functions<T>::type;
template <Record T>
  using get_accessible_member_functions_t = typename get_accessible_member_functions<T>::type;
template <Record T>
  using get_member_functions_t = typename get_member_functions<T>::type;
template <Record T>
  using get_public_member_types_t = typename get_public_member_types<T>::type;
template <Record T>
  using get_accessible_member_types_t = typename get_accessible_member_types<T>::type;
template <Record T>
  using get_member_types_t = typename get_member_types<T>::type;
template <Record T>
  using get_constructors_t = typename get_constructors<T>::type;
template <Record T>
  using get_destructor_t = typename get_destructor<T>::type;
template <Record T>
  using get_operators_t = typename get_operators<T>::type;
template <Class T>
  using get_public_base_classes_t = typename get_public_base_classes<T>::type;
template <Class T>
  using get_accessible_base_classes_t = typename get_accessible_base_classes<T>::type;
template <Class T>
  using get_base_classes_t = typename get_base_classes<T>::type;

// \ref{reflect.ops.enum} Enum operations
template <Enum T> struct is_scoped_enum;
template <Enum T> struct get_enumerators;
template <Enum T> struct get_underlying_type;

template <Enum T>
  constexpr auto is_scoped_enum_v = is_scoped_enum<T>::value;
template <Enum T>
  using get_enumerators_t = typename get_enumerators<T>::type;
template <Enum T>
  using get_underlying_type_t = typename get_underlying_type<T>::type;

// \ref{reflect.ops.value} Value operations
template <Constant T> struct get_constant;
template <Variable T> struct is_constexpr<T>;
template <Variable T> struct is_static<T>;
template <Variable T> struct is_thread_local;
template <Variable T> struct get_pointer<T>;

template <Constant T>
  constexpr auto get_constant_v = get_constant<T>::value;
template <Variable T>
  constexpr auto is_thread_local_v = is_thread_local<T>::value;

// \ref{reflect.ops.derived} Base operations
template <Base T> struct get_class;
template <Base T> struct is_virtual<T>;
template <Base T> struct is_public<T>;
template <Base T> struct is_protected<T>;
template <Base T> struct is_private<T>;

template <Base T>
  using get_class_t = typename get_class<T>::type;

// \ref{reflect.ops.namespace} Namespace operations
template <Namespace T> struct is_inline<T>;

// \ref{reflect.ops.fctparam} FunctionParameter operations
template <FunctionParameter T> struct has_default_argument;

template <FunctionParameter T>
  constexpr auto has_default_argument_v = has_default_argument<T>::value;

// \ref{reflect.ops.callable} Callable operations
template <Callable T> struct get_parameters;
template <Callable T> struct is_vararg;
template <Callable T> struct is_constexpr<T>;
template <Callable T> struct is_noexcept;
template <Callable T> struct is_inline<T>;
template <Callable T> struct is_deleted;

template <Callable T>
  using get_parameters_t = typename get_parameters<T>::type;
template <Callable T>
  constexpr auto is_vararg_v = is_vararg<T>::value;
template <Callable T>
  constexpr auto is_deleted_v = is_deleted<T>::value;

// \ref{reflect.ops.expr.paren} ParenthesizedExpression operations
template <ParenthesizedExpression T> struct get_subexpression;

template <ParenthesizedExpression T>
   using get_subexpression_t = typename get_subexpression<T>::type;

// \ref{reflect.ops.expr.fctcall} FunctionCallExpression operations
template <FunctionCallExpression T> struct get_callable;

template <FunctionCallExpression T>
  using get_callable_t = typename get_callable<T>::type;

// \ref{reflect.ops.expr.fcttypeconv} FunctionalTypeConversion operations
template <FunctionalTypeConversion T> struct get_constructor;

template <FunctionalTypeConversion T>
  using get_constructor_t = typename get_constructor<T>::type;

// \ref{reflect.ops.fct} Function operations
template <Function T> struct get_pointer<T>;

// \ref{reflect.ops.memfct} MemberFunction operations
template <MemberFunction T> struct is_static<T>;
template <MemberFunction T> struct is_const;
template <MemberFunction T> struct is_volatile;
template <MemberFunction T> struct has_lvalueref_qualifier;
template <MemberFunction T> struct has_rvalueref_qualifier;
template <MemberFunction T> struct is_virtual<T>;
template <MemberFunction T> struct is_pure_virtual<T>;
template <MemberFunction T> struct is_override;
template <MemberFunction T> struct is_final<T>;

template <MemberFunction T>
  constexpr auto is_const_v = is_const<T>::value;
template <MemberFunction T>
  constexpr auto is_volatile_v = is_volatile<T>::value;
template <MemberFunction T>
  constexpr auto has_lvalueref_qualifier_v = has_lvalueref_qualifier<T>::value;
template <MemberFunction T>
  constexpr auto has_rvalueref_qualifier_v = has_rvalueref_qualifier<T>::value;
template <MemberFunction T>
  constexpr auto is_override_v = is_override<T>::value;

// \ref{reflect.ops.specialfct} SpecialMemberFunction operations
template <SpecialMemberFunction T> struct is_implicitly_declared;
template <SpecialMemberFunction T> struct is_defaulted;

template <SpecialMemberFunction T>
  constexpr auto is_implicitly_declared_v = is_implicitly_declared<T>::value;
template <SpecialMemberFunction T>
  constexpr auto is_defaulted_v = is_defaulted<T>::value;

// \ref{reflect.ops.ctor} Constructor operations
template <Constructor T> struct is_explicit<T>;

// \ref{reflect.ops.dtor} Destructor operations
template <Destructor T> struct is_virtual<T>;
template <Destructor T> struct is_pure_virtual<T>;

// \ref{reflect.ops.convfct} ConversionOperator operations
template <ConversionOperator T> struct is_explicit<T>;

// \ref{reflect.ops.lambda} Lambda operations
template <Lambda T> struct get_captures;
template <Lambda T> struct uses_default_copy_capture;
template <Lambda T> struct uses_default_reference_capture;
template <Lambda T> struct is_call_operator_const;

template <Lambda T>
  using get_captures_t = typename get_captures<T>::type;
template <Lambda T>
  constexpr auto uses_default_copy_capture_v = uses_default_copy_capture<T>::value;
template <Lambda T>
  constexpr auto uses_default_reference_capture_v = uses_default_reference_capture<T>::value;
template <Lambda T>
  constexpr auto is_call_operator_const_v = is_call_operator_const<T>::value;

// \ref{reflect.ops.lambdacapture} LambdaCapture operations
template <LambdaCapture T> struct is_explicitly_captured;
template <LambdaCapture T> struct is_init_capture;

template <LambdaCapture T>
  constexpr auto is_explicitly_captured_v = is_explicitly_captured<T>::value;
template <LambdaCapture T>
  constexpr auto is_init_capture_v = is_init_capture<T>::value;

} // inline namespace v1
} // namespace reflect
} // namespace experimental
} // namespace std
\end{codeblock}
\end{std.txt}

\rSec2[reflect.concepts]{Concepts for meta-object types}

\begin{std.txt}\color{addclr}
\pnum
The operations on meta-object types defined here require meta-object types to
satisfy certain concepts (\cxxref{dcl.spec.concept}). These concepts are also used to
specify the result type for \emph{TransformationTrait} type transformations that
yield meta-object types.
\begin{note} Unlike \tcode{std::is_enum}, \tcode{std::experimental::reflect::is_enum} operates on meta-object types.\end{note}

\end{std.txt}

\rSec3[reflect.concepts.object]{Concept \tcode{Object}}

\begin{std.txt}\color{addclr}

\begin{itemdecl}
template <class T> concept bool Object = @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{Object<T>} is true if and only if \tcode{T} is a meta-object type, as generated by the \tcode{reflexpr} operator or any of the meta-object operations that in turn generate meta-object types.

\end{itemdescr}
\end{std.txt}

\rSec3[reflect.concepts.objseq]{Concept \tcode{ObjectSequence}}
\begin{std.txt}\color{addclr}

\begin{itemdecl}
template <class T> concept bool ObjectSequence = Object<T> && @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{ObjectSequence<T>} is true if and only if \tcode{T} is a sequence of \tcode{Object}s, generated by a meta-object operation.

\end{itemdescr}
\end{std.txt}

\rSec3[reflect.concepts.tempparmscope]{Concept \tcode{TemplateParameterScope}}

\begin{std.txt}\color{addclr}

\begin{itemdecl}
template <class T> concept bool TemplateParameterScope = Scope<T> && @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{TemplateParameterScope<T>} is \tcode{true} if and only if \tcode{T} is a \tcode{Scope} reflecting the scope of a template \grammarterm{type-parameter}, generated by a metaobject operation. \begin{note} It represents the template parameter scope (\cxxref{basic.scope.temp}), providing a scope to the \tcode{Alias} reflecting a template \grammarterm{type-parameter}.\end{note}

\end{itemdescr}
\end{std.txt}

\rSec3[reflect.concepts.named]{Concept \tcode{Named}}

\begin{std.txt}\color{addclr}

\begin{itemdecl}
template <class T> concept bool Named = Object<T> && @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{Named<T>} is true if and only if \tcode{T} has an associated (possibly empty) name.

\end{itemdescr}
\end{std.txt}

\rSec3[reflect.concepts.alias]{Concept \tcode{Alias}}


\begin{std.txt}\color{addclr}

\begin{itemdecl}
template <class T> concept bool Alias = Named<T> && ScopeMember<T> && @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{Alias<T>} is true if and only if \tcode{T} reflects a \tcode{typedef} declaration, an \grammarterm{alias-declaration}, a \grammarterm{namespace-alias}, a template \grammarterm{type-parameter}, a \grammarterm{decltype-specifier}, or a declaration introduced by a \grammarterm{using-declaration}.
\begin{note}
The \tcode{Scope} of an \tcode{Alias} is the scope that the alias was injected into.
For an \tcode{Alias} reflecting a template \grammarterm{type-parameter}, that scope is its \tcode{TemplateParameterScope}.
\end{note}
\begin{example}
\begin{codeblock}
namespace N {
   struct A;
}
namespace M {
   using X = N::A;
}
struct B {
   int i;
};
struct C {
   using B::i;
};
using M_X_t = reflexpr(M::X);
using M_X_scope_t = get_scope_t<M_X_t>;
using C_i_t = reflexpr(C::i);
using C_i_scope_t = get_scope_t<C_i_t>;
\end{codeblock}
The scope reflected by \tcode{M_X_scope_t} is \tcode{M}, not \tcode{N}; the scope reflected by \tcode{C_i_scope_t} is \tcode{C}, not \tcode{B}.
\end{example}

\pnum
Type transformations (\ref{reflect.ops}) never yield an \tcode{Alias}; instead, they yield the aliased entity.


\end{itemdescr}
\end{std.txt}

\rSec3[reflect.concepts.recordmember]{Concept \tcode{RecordMember}}

\begin{std.txt}\color{addclr}

\begin{itemdecl}
template <class T> concept bool RecordMember = ScopeMember<T> && @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{RecordMember<T>} is true if and only if \tcode{T} reflects a \grammarterm{member-declaration}.

\end{itemdescr}
\end{std.txt}

\rSec3[reflect.concepts.enumerator]{Concept \tcode{Enumerator}}

\begin{std.txt}\color{addclr}

\begin{itemdecl}
template <class T> concept bool Enumerator = Constant<T> && @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{Enumerator<T>} is true if and only if \tcode{T} reflects an enumerator. \begin{note} The \tcode{Scope} of an \tcode{Enumerator} is its type also for enumerations that are unscoped enumeration types. \end{note}

\end{itemdescr}
\end{std.txt}

\rSec3[reflect.concepts.variable]{Concept \tcode{Variable}}

\begin{std.txt}\color{addclr}

\begin{itemdecl}
template <class T> concept bool Variable = Typed<T> && ScopeMember<T> && @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{Variable<T>} is true if and only if \tcode{T} reflects a variable or data member.

\end{itemdescr}
\end{std.txt}

\rSec3[reflect.concepts.scopemember]{Concept \tcode{ScopeMember}}

\begin{std.txt}\color{addclr}

\begin{itemdecl}
template <class T> concept bool ScopeMember = Named<T> && @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{ScopeMember<T>} is true if and only if \tcode{T} satisfies \tcode{RecordMember}, \tcode{Enumerator}, or \tcode{Variable}, or if \tcode{T} reflects a namespace that is not the global namespace. \begin{note} The scope of members of an unnamed union is the unnamed union; the scope of enumerators is their type. \end{note}

\end{itemdescr}
\end{std.txt}

\rSec3[reflect.concepts.typed]{Concept \tcode{Typed}}

\begin{std.txt}\color{addclr}

\begin{itemdecl}
template <class T> concept bool Typed = Object<T> && @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{Typed<T>} is true if and only if \tcode{T} reflects an entity with a type.

\end{itemdescr}
\end{std.txt}

\rSec3[reflect.concepts.namespace]{Concept \tcode{Namespace}}

\begin{std.txt}\color{addclr}

\begin{itemdecl}
template <class T> concept bool Namespace = Named<T> && Scope<T> && @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{Namespace<T>} is true if and only if \tcode{T} reflects a namespace (including the global namespace). \begin{note} Any such \tcode{T} that does not reflect the global namespace also satisfies \tcode{ScopeMember}. \end{note}

\end{itemdescr}
\end{std.txt}

\rSec3[reflect.concepts.globalscope]{Concept \tcode{GlobalScope}}

\begin{std.txt}\color{addclr}

\begin{itemdecl}
template <class T> concept bool GlobalScope = Namespace<T> && @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{GlobalScope<T>} is true if and only if \tcode{T} reflects the global namespace. \begin{note} Any such \tcode{T} does not satisfy \tcode{ScopeMember}. \end{note}

\end{itemdescr}
\end{std.txt}

\rSec3[reflect.concepts.class]{Concept \tcode{Class}}

\begin{std.txt}\color{addclr}

\begin{itemdecl}
template <class T> concept bool Class = Record<T> && @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{Class<T>} is true if and only if \tcode{T} reflects a non-union class type.

\end{itemdescr}
\end{std.txt}

\rSec3[reflect.concepts.enum]{Concept \tcode{Enum}}

\begin{std.txt}\color{addclr}

\begin{itemdecl}
template <class T> concept bool Enum = Type<T> && Scope<T> && ScopeMember<T> && @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{Enum<T>} is true if and only if \tcode{T} reflects an enumeration type.

\end{itemdescr}
\end{std.txt}

\rSec3[reflect.concepts.record]{Concept \tcode{Record}}

\begin{std.txt}\color{addclr}

\begin{itemdecl}
template <class T> concept bool Record = Type<T> && Scope<T> && ScopeMember<T> && @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{Record<T>} is true if and only if \tcode{T} reflects a class type.

\end{itemdescr}
\end{std.txt}

\rSec3[reflect.concepts.scope]{Concept \tcode{Scope}}

\begin{std.txt}\color{addclr}

\begin{itemdecl}
template <class T> concept bool Scope = Object<T> && @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{Scope<T>} is true if and only if \tcode{T} reflects a namespace (including the global namespace), class, enumeration, function, closure type, or is a \tcode{TemplateParameterScope}. \begin{note} Any such \tcode{T} that does not reflect the global namespace also satisfies \tcode{ScopeMember}. \end{note}

\end{itemdescr}
\end{std.txt}

\rSec3[reflect.concepts.type]{Concept \tcode{Type}}

\begin{std.txt}\color{addclr}

\begin{itemdecl}
template <class T> concept bool Type = Named<T> && @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{Type<T>} is true if and only if \tcode{T} reflects a type.
\begin{note}
Some types \tcode{T} also satisfy \tcode{ScopeMember}; others, for instance those reflecting \cv-qualified types or fundamental types, do not.
\end{note}

\end{itemdescr}
\end{std.txt}

\rSec3[reflect.concepts.const]{Concept \tcode{Constant}}

\begin{std.txt}\color{addclr}

\begin{itemdecl}
template <class T> concept bool Constant = Typed<T> && ScopeMember<T> && @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{Constant<T>} is true if and only if \tcode{T} reflects an enumerator or a
\tcode{constexpr} variable.

\end{itemdescr}
\end{std.txt}

\rSec3[reflect.concepts.base]{Concept \tcode{Base}}

\begin{std.txt}\color{addclr}

\begin{itemdecl}
template <class T> concept bool Base = Object<T> && @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{Base<T>} is true if and only if \tcode{T} reflects a direct base class, as returned by the template \tcode{get_base_classes}.

\end{itemdescr}
\end{std.txt}

\rSec3[reflect.concepts.fctparam]{Concept \tcode{FunctionParameter}}
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <class T> concept bool FunctionParameter = Typed<T> && ScopeMember<T> && @\seebelow@;
\end{itemdecl}
\begin{itemdescr}
\pnum
\tcode{FunctionParameter<T>} is \tcode{true} if and only if \tcode{T} reflects a function parameter.
\begin{note} The \tcode{Scope} of a \tcode{FunctionParameter} is the \tcode{Callable} to which this parameter appertains. \end{note}
\begin{note} A \tcode{FunctionParameter} does not satisfy \tcode{Variable}, and thus does not offer an interface for getting the pointer to a parameter. \end{note}
\end{itemdescr}
\end{std.txt}

\rSec3[reflect.concepts.callable]{Concept \tcode{Callable}}
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <class T> concept bool Callable = Scope<T> && ScopeMember<T> && @\seebelow@;
\end{itemdecl}
\begin{itemdescr}
\pnum
\tcode{Callable<T>} is \tcode{true} if and only if \tcode{T} reflects a function, including constructors and destructors.
\end{itemdescr}
\end{std.txt}

\rSec3[reflect.concepts.expr]{Concept \tcode{Expression}}
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <class T> concept bool Expression = Object<T> && @\seebelow@;
\end{itemdecl}
\begin{itemdescr}
\pnum
\tcode{Expression<T>} is \tcode{true} if and only if \tcode{T} reflects an
expression (Clause \cxxref{expr}).
\end{itemdescr}
\end{std.txt}

\rSec3[reflect.concepts.expr.paren]{Concept \tcode{ParenthesizedExpression}}
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <class T> concept bool ParenthesizedExpression = Expression<T> && @\seebelow@;
\end{itemdecl}
\begin{itemdescr}
\pnum
\tcode{ParenthesizedExpression<T>} is \tcode{true} if and only if \tcode{T}
reflects a parenthesized expression (\cxxref{expr.prim.general}).
\end{itemdescr}
\end{std.txt}

\rSec3[reflect.concepts.expr.fctcall]{Concept \tcode{FunctionCallExpression}}
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <class T> concept bool FunctionCallExpression = Expression<T> && @\seebelow@;
\end{itemdecl}
\begin{itemdescr}
\pnum
\tcode{FunctionCallExpression<T>} is \tcode{true} if and only if \tcode{T}
reflects a \grammarterm{function-call-expression} (\cxxref{expr.call}).
\end{itemdescr}
\end{std.txt}

\rSec3[reflect.concepts.expr.type.fctconv]{Concept \tcode{FunctionalTypeConversion}}
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <class T> concept bool FunctionalTypeConversion = Expression<T> && @\seebelow@;
\end{itemdecl}
\begin{itemdescr}
\pnum
\tcode{FunctionalTypeConversion<T>} is \tcode{true} if and only if \tcode{T}
reflects a \grammarterm{functional-type-conv-expression} (\cxxref{expr.type.conv}).
\end{itemdescr}
\end{std.txt}

\rSec3[reflect.concepts.fct]{Concept \tcode{Function}}
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <class T> concept bool Function = Typed<T> && Callable<T> && @\seebelow@;
\end{itemdecl}
\begin{itemdescr}
\pnum
\tcode{Function<T>} is \tcode{true} if and only if \tcode{T} reflects a function, excluding constructors and destructors.
\end{itemdescr}
\end{std.txt}

\rSec3[reflect.concepts.memfct]{Concept \tcode{MemberFunction}}
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <class T> concept bool MemberFunction = RecordMember<T> && Function<T> && @\seebelow@;
\end{itemdecl}
\begin{itemdescr}
\pnum
\tcode{MemberFunction<T>} is \tcode{true} if and only if \tcode{T} reflects a member function, excluding constructors and destructors.
\end{itemdescr}
\end{std.txt}

\rSec3[reflect.concepts.specialfct]{Concept \tcode{SpecialMemberFunction}}
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <class T> concept bool SpecialMemberFunction = RecordMember<T> && @\seebelow@;
\end{itemdecl}
\begin{itemdescr}
\pnum
\tcode{SpecialMemberFunction<T>} is \tcode{true} if and only if \tcode{T}
reflects a special member function (Clause \cxxref{special}).
\end{itemdescr}
\end{std.txt}

\rSec3[reflect.concepts.ctor]{Concept \tcode{Constructor}}
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <class T> concept bool Constructor = Callable<T> && RecordMember<T> && @\seebelow@;
\end{itemdecl}
\begin{itemdescr}
\pnum
\tcode{Constructor<T>} is \tcode{true} if and only if \tcode{T} reflects a constructor. \begin{note} Some types that satisfy \tcode{Constructor} also satisfy \tcode{SpecialMemberFunction}. \end{note}
\end{itemdescr}
\end{std.txt}

\rSec3[reflect.concepts.dtor]{Concept \tcode{Destructor}}
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <class T>
concept bool Destructor = Callable<T> && SpecialMemberFunction<T> && @\seebelow@;
\end{itemdecl}
\begin{itemdescr}
\pnum
\tcode{Destructor<T>} is \tcode{true} if and only if \tcode{T} reflects a destructor.
\end{itemdescr}
\end{std.txt}

\rSec3[reflect.concepts.oper]{Concept \tcode{Operator}}
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <class T> concept bool Operator = Function<T> && @\seebelow@;
\end{itemdecl}
\begin{itemdescr}
\pnum
\tcode{Operator<T>} is \tcode{true} if and only if \tcode{T} reflects an operator function (\cxxref{over.oper}) or a conversion function (\cxxref{class.conv.fct}). \begin{note} Some types that satisfy \tcode{Operator} also satisfy \tcode{MemberFunction} or \tcode{SpecialMemberFunction}. \end{note}
\end{itemdescr}
\end{std.txt}

\rSec3[reflect.concepts.convfct]{Concept \tcode{ConversionOperator}}
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <class T>
concept bool ConversionOperator = MemberFunction<T> && Operator<T> && @\seebelow@;
\end{itemdecl}
\begin{itemdescr}
\pnum
\tcode{ConversionOperator<T>} is \tcode{true} if and only if \tcode{T} reflects a conversion function (\cxxref{class.conv.fct}).
\end{itemdescr}
\end{std.txt}

\rSec3[reflect.concepts.lambda]{Concept \tcode{Lambda}}
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <class T> concept bool Lambda = Type<T> && Scope<T> && @\seebelow@;
\end{itemdecl}
\begin{itemdescr}
\pnum
\tcode{Lambda<T>} is \tcode{true} if and only if \tcode{T} reflects a closure type (excluding generic lambdas).
\end{itemdescr}
\end{std.txt}

\rSec3[reflect.concepts.lambdacapture]{Concept \tcode{LambdaCapture}}
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <class T> concept bool LambdaCapture = Variable<T> && @\seebelow@;
\end{itemdecl}
\begin{itemdescr}
\pnum
\tcode{LambdaCapture<T>} is \tcode{true} if and only if \tcode{T} reflects a lambda capture as introduced by the capture list or by capture defaults. \begin{note} The \tcode{Scope} of a \tcode{LambdaCapture} is its immediately enclosing \tcode{Lambda}. \end{note}
\end{itemdescr}
\end{std.txt}

\rSec2[reflect.ops]{Meta-object operations}

\begin{std.txt}\color{addclr}
\pnum
A meta-object operation extracts information from meta-object types. It is a class template taking one or more arguments, at least one of which models the \tcode{Object} concept. The result of a meta-object operation can be either a constant expression (\cxxref{expr.const}) or a type.

\pnum
Some operations specify result types with a nested type called \tcode{type} that satisfies one of the concepts in \tcode{reflect}.
These nested types will possibly satisfy other concepts, for instance more specific ones, or independent ones, as applicable for the entity reflected by the nested type.
\begin{example}\begin{codeblock}
struct X {};
X x;
using x_t = get_type_t<reflexpr(x)>;\end{codeblock}
While \tcode{get_type_t} is specified to be a \tcode{Type}, \tcode{x_t} also satisfies \tcode{Class}. \end{example}
Alias entities are not returned by meta-object operations (\ref{reflect.concepts.alias}).

\pnum
If subsequent specializations of operations on the same reflected entity could give different constant expression results (for instance for \tcode{get_name_v} because the parameter's function is redeclared with a different parameter name between the two points of instantiation), the program is ill-formed, no diagnostic required.
   \begin{example}\begin{codeblock}
void func(int a);
auto x1 = get_name_v<get_element_t<0, get_parameters_t<reflexpr(func(42))>>>;
void func(int b);
auto x2 = get_name_v<get_element_t<0, get_parameters_t<reflexpr(func(42))>>>; // ill-formed,
                                                                    // no diagnostic required\end{codeblock}
\end{example}

\end{std.txt}

\rSec3[reflect.ops.object]{Object operations}

\begin{std.txt}\color{addclr}

\begin{itemdecl}
template <Object T1, Object T2> struct reflects_same;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of \tcode{reflects_same<T1, T2>} shall meet the \tcode{BinaryTypeTrait} requirements (\cxxref{meta.rqmts}),
    with a base characteristic of \tcode{true_type} if 
\begin{itemize}
  \item \tcode{T1} and \tcode{T2} reflect the same alias, or
  \item neither \tcode{T1} nor \tcode{T2} reflect an alias and \tcode{T1} and \tcode{T2} reflect the same aspect;
\end{itemize}
    otherwise, with a base characteristic of \tcode{false_type}.

\pnum
\begin{example}
With
\begin{codeblock}
class A;
using a0 = reflexpr(A);
using a1 = reflexpr(A);
class A {};
using a2 = reflexpr(A);
constexpr bool b1 = is_same_v<a0, a1>; // unspecified value
constexpr bool b2 = reflects_same_v<a0, a1>; // true
constexpr bool b3 = reflects_same_v<a0, a2>; // true

struct C { };
using C1 = C;
using C2 = C;
constexpr bool b4 = reflects_same_v<reflexpr(C1), reflexpr(C2)>; // false
\end{codeblock}
\end{example}

\end{itemdescr}


\begin{itemdecl}
template <Object T> struct get_source_line;
template <Object T> struct get_source_column;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of above templates shall meet the \tcode{UnaryTypeTrait} requirements (\cxxref{meta.rqmts}) with a base characteristic of \tcode{integral_constant<uint_least32_t>} and a value of the presumed line number (\cxxref{cpp.predefined}) (for \tcode{get_source_line<T>}) and an implementation-defined value representing some offset from the start of the line (for \tcode{get_source_column<T>}) of a declaration of the entity or typedef described by \tcode{T}.
\end{itemdescr}

\begin{itemdecl}
template <Object T> struct get_source_file_name;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of \tcode{get_source_file_name<T>} shall meet the \tcode{UnaryTypeTrait} requirements (\cxxref{meta.rqmts}) with a static data member named \tcode{value} of type \tcode{const char (\&)[N]}, referencing a static, constant expression character array (NTBS) of length \tcode{N}, as if declared as \tcode{static constexpr char STR[N] = ...;}. The value of the NTBS is the presumed name of the source file (\cxxref{cpp.predefined}) of a declaration of the entity or typedef described by \tcode{T}.

\end{itemdescr}

\end{std.txt}

\rSec3[reflect.ops.objseq]{ObjectSequence operations}

\begin{std.txt}\color{addclr}

\begin{itemdecl}
template <ObjectSequence T> struct get_size;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of \tcode{get_size<T>} shall meet the \tcode{UnaryTypeTrait} requirements (\cxxref{meta.rqmts}) with a base characteristic of \tcode{integral_constant<size_t, N>}, where \tcode{N} is the number of elements in the object sequence.
\end{itemdescr}

\begin{itemdecl}
template <size_t I, ObjectSequence T> struct get_element;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of \tcode{get_element<I, T>} shall meet the \tcode{TransformationTrait} requirements (\cxxref{meta.rqmts}). The nested type named \tcode{type} corresponds to the \tcode{I}th element \tcode{Object} in \tcode{T}, where the indexing is zero-based.
\end{itemdescr}

\begin{itemdecl}
template <template <class...> class Tpl, ObjectSequence T> struct unpack_sequence;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of \tcode{unpack_sequence<Tpl, T>} shall meet the \tcode{TransformationTrait} requirements (\cxxref{meta.rqmts}). The nested type named \tcode{type} designates the template \tcode{Tpl} specialized with the element \tcode{Object}s in \tcode{T}.
\end{itemdescr}
\end{std.txt}

\rSec3[reflect.ops.named]{Named operations}

\begin{std.txt}\color{addclr}

\begin{itemdecl}
template <Named T> struct is_unnamed;
template <Named T> struct get_name;
template <Named T> struct get_display_name;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of \tcode{is_unnamed<T>} shall meet the \tcode{UnaryTypeTrait} requirements (\cxxref{meta.rqmts}) with a base characteristic as specified below.

\pnum
All specializations of \tcode{get_name<T>} and \tcode{get_display_name<T>} shall meet the \tcode{UnaryTypeTrait} requirements (\cxxref{meta.rqmts}) with a static data member named \tcode{value} of type \tcode{const char (\&)[N]}, referencing a static, constant expression character array (NTMBS) of length \tcode{N}, as if declared as \tcode{static constexpr char STR[N] = ...;}.

\pnum
The value of \tcode{get_display_name_v<T>} is the empty string if \tcode{T} reflects an unnamed entity; otherwise the value is implementation defined.

\pnum
The value of \tcode{get_name_v<T>} refers to a string literal whose \grammarterm{s-char-sequence} is obtained by the first matching case in the following list:

\begin{itemize}
\item for \tcode{T} reflecting an alias, the unqualified name of the aliasing declaration;
\item for \tcode{T} reflecting an unnamed entity, the empty string;
\item for \tcode{T} reflecting a specialization of a class, function (except for conversion functions, constructors, operator functions, or literal operators), or variable template, its \grammarterm{template-name};
\item for \tcode{T} reflecting a \cv-unqualified type that is
    \begin{itemize}
    \item a \grammarterm{type-parameter}, the identifier introduced by the \grammarterm{type-parameter};
    \item a class type, its \grammarterm{class-name};
    \item an enumeration type, its \grammarterm{enum-name};
    \item a fundamental type other than \tcode{std::nullptr_t}, the name stated in the "Type" column of Table \cxxref{tref:simple.type.specifiers} in \cxxref{dcl.type.simple};
    \end{itemize}
\item for \tcode{T} reflecting
    \begin{itemize}
    \item a namespace, its \grammarterm{namespace-name};
    \item a variable, enumerator, data member, or function (except for conversion functions, constructors, operator functions, or literal operators), its unqualified name;
    \item a function parameter, its name;
    \item a constructor, the \grammarterm{injected-class-name} of its class;
    \item a destructor, the \grammarterm{injected-class-name} of its class, prefixed by the character \tcode{’\tilde’};
    \item an operator function, the operator element of the relevant \grammarterm{operator-function-id};
    \item a literal operator, the \grammarterm{s-char-sequence} \tcode{\textbackslash"\textbackslash"} followed by the literal suffix identifier of the operator's \grammarterm{literal-operator-id};
    \item a conversion function, the same characters as \tcode{get_name_v<R>}, with \tcode{R} reflecting the type represented by the \grammarterm{conversion-type-id}.
    \end{itemize}
\item In all other cases, the string’s value is the empty string.
\end{itemize}

\pnum
\begin{note}
With
\begin{codeblock}
namespace n { template <class T> class A; }
using a_m = reflexpr(n::A<int>);
\end{codeblock}
the value of \tcode{get_name_v<a_m>} is \tcode{"A"} while the value of \tcode{get_display_name_v<a_m>} might be \tcode{"n::A<int>"}.
\end{note}

\pnum
The base characteristic of \tcode{is_unnamed<T>} is \tcode{true_type} if the value of \tcode{get_name_v<T>} is the empty string, otherwise it is \tcode{false_type}.

\pnum
Subsequent specializations of \tcode{get_name<T>} on the same reflected
function parameter can render the program ill-formed, no diagnostic required
(\ref{reflect.ops}).

\end{itemdescr}

\end{std.txt}


\rSec3[reflect.ops.alias]{Alias operations}

\begin{std.txt}\color{addclr}

\begin{itemdecl}
template <Alias T> struct get_aliased;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of \tcode{get_aliased<T>} shall meet the \tcode{TransformationTrait} requirements (\cxxref{meta.rqmts}). The nested type named \tcode{type} is the \tcode{Named} meta-object type reflecting
\begin{itemize}
\item the redefined name, if \tcode{T} reflects an alias;
\item the template specialization's template argument type, if \tcode{T} reflects a template \grammarterm{type-parameter};
\item the original declaration introduced by a \grammarterm{using-declaration};
\item the aliased namespace of a \grammarterm{namespace-alias};
\item the type denoted by the \grammarterm{decltype-specifier}.
\end{itemize}

\pnum
The nested type named \tcode{type} is not an \tcode{Alias}; instead, it is reflecting the underlying non-\tcode{Alias} entity.

\pnum
\begin{example}
For
\begin{codeblock}
using i0 = int; using i1 = i0;
\end{codeblock}
\tcode{get_aliased_t<reflexpr(i1)>} reflects \tcode{int}.
\end{example}

\end{itemdescr}
\end{std.txt}

\rSec3[reflect.ops.type]{Type operations}

\begin{std.txt}\color{addclr}

\begin{itemdecl}
template <Typed T> struct get_type;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of \tcode{get_type<T>} shall meet the \tcode{TransformationTrait} requirements (\cxxref{meta.rqmts}). The nested type named \tcode{type} is the \tcode{Type} reflecting the type of the entity reflected by \tcode{T}.

\pnum
\begin{example}
For
\begin{codeblock}
int v; using v_m = reflexpr(v);
\end{codeblock}
\tcode{get_type_t<v_m>} reflects \tcode{int}.
\end{example}

\pnum
If the entity reflected by \tcode{T} is a static data member that is declared to have a type array of unknown bound in the class definition, possible specifications of the array bound will only be accessible when the \grammarterm{reflexpr-operand} is the data member.

\pnum
\begin{note}
For
\begin{codeblock}
struct C {
   static int arr[][17];
};
int C::arr[42][17];
using C1 = get_type_t<get_element_t<0, get_data_members_t<reflexpr(C)>>>;
using C2 = get_type_t<reflexpr(C::arr)>;
\end{codeblock}
\tcode{C1} reflects \tcode{int[][17]} while \tcode{C2} reflects \tcode{int[42][17]}.
\end{note}

\end{itemdescr}
\begin{itemdecl}
template <Type T> struct get_reflected_type;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of \tcode{get_reflected_type<T>} shall meet the \tcode{TransformationTrait} requirements (\cxxref{meta.rqmts}). The nested type named \tcode{type} is the type reflected by \tcode{T}.

\pnum
\begin{example}
For
\begin{codeblock}
using int_m = reflexpr(int);
get_reflected_type_t<int_m> x; // x is of type int
\end{codeblock}
\end{example}
\end{itemdescr}

\begin{itemdecl}
template <Type T> struct is_enum;
template <Type T> struct is_union;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of \tcode{is_enum<T>} and \tcode{is_union<T>} shall meet the \tcode{UnaryTypeTrait} requirements (\cxxref{meta.rqmts}). If \tcode{T} reflects an enumeration type (a union), the base characteristic of \tcode{is_enum<T>} (\tcode{is_union<T>}) is \tcode{true_type}, otherwise it is \tcode{false_type}.
\end{itemdescr}

\begin{itemdecl}
template <Class T> struct uses_class_key;
template <Class T> struct uses_struct_key;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of \tcode{uses_class_key<T>} and \tcode{uses_struct_key<T>} shall meet the \tcode{UnaryTypeTrait} requirements (\cxxref{meta.rqmts}). If \tcode{T} reflects a class for which all declarations use \grammarterm{class-key} \tcode{class} (for \tcode{uses_class_key<T>}) or \tcode{struct} (for \tcode{uses_struct_key<T>}), the base characteristic of the respective template specialization is \tcode{true_type}.
If \tcode{T} reflects a class for which no declaration uses \grammarterm{class-key} \tcode{class} (for \tcode{uses_class_key<T>}) or \tcode{struct} (for \tcode{uses_struct_key<T>}), the base characteristic of the respective template specialization is \tcode{false_type}. Otherwise, it is unspecified whether the base characteristic is \tcode{true_type} or \tcode{false_type}.
\end{itemdescr}
\end{std.txt}

\rSec3[reflect.ops.member]{Member operations}

\begin{std.txt}\color{addclr}
\pnum
A specialization of any of these templates with a meta-object type that is
reflecting an incomplete type renders the program ill-formed.  Such errors are
not in the immediate context (\cxxref{temp.deduct}).


\begin{itemdecl}
template <ScopeMember T> struct get_scope;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of \tcode{get_scope<T>} shall meet the \tcode{TransformationTrait} requirements (\cxxref{meta.rqmts}). The nested type named \tcode{type} is the \tcode{Scope} reflecting a scope \emph{S}. With \emph{ST} being the scope of the declaration of the entity, alias or value reflected by \tcode{T}, \emph{S} is found as the innermost scope enclosing \emph{ST} that is either a namespace scope (including global scope), class scope, enumeration scope, function scope, or immediately enclosing closure type (for lambda captures). For members of an unnamed union, this innermost scope is the unnamed union. For enumerators of unscoped enumeration types, this innermost scope is their enumeration type.
For a template \grammarterm{type-parameter}, this innermost scope is the \tcode{TemplateParameterScope} representing the template parameter scope in which it has been declared.
\end{itemdescr}

\begin{itemdecl}
template <RecordMember T> struct is_public<T>;
template <RecordMember T> struct is_protected<T>;
template <RecordMember T> struct is_private<T>;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of these partial template specializations shall meet the \tcode{UnaryTypeTrait} requirements (\cxxref{meta.rqmts}). If \tcode{T} reflects a public member (for \tcode{is_public}), protected member (for \tcode{is_protected}), or private member (for \tcode{is_private}), the base characteristic of the respective template specialization is \tcode{true_type}, otherwise it is \tcode{false_type}.
\end{itemdescr}

\end{std.txt}

\rSec3[reflect.ops.record]{Record operations}

\begin{std.txt}\color{addclr}
\pnum
A specialization of any of these templates with a meta-object type that is
reflecting an incomplete type renders the program ill-formed.  Such errors are
not in the immediate context (\cxxref{temp.deduct}).
Members introduced by \grammarterm{using-declaration}{s} (\cxxref{namespace.udecl}) are included in the sequences below where applicable; the \tcode{Scope} of these members remains that of the declaration of the referenced entity. \begin{note} These members are not \tcode{Aliase}s, see \ref{reflect.ops}. A member injected into a derived class may have different access. \end{note}

\begin{itemdecl}
template <Record T> struct get_public_data_members;
template <Record T> struct get_accessible_data_members;
template <Record T> struct get_data_members;
template <Record T> struct get_public_member_functions;
template <Record T> struct get_accessible_member_functions;
template <Record T> struct get_member_functions;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of these templates shall meet the \tcode{TransformationTrait} requirements (\cxxref{meta.rqmts}). The nested type named \tcode{type} designates a meta-object type satisfying \tcode{ObjectSequence}, containing elements which satisfy \tcode{RecordMember} and reflect the following subset of direct non-template members that are either declared in the class reflected by \tcode{T} or that are introduced by a using-declaration in the class reflected by \tcode{T}:
\begin{itemize}
  \item for \tcode{get_data_members} (\tcode{get_member_functions}), all data (function, including constructor and destructor) members.
  \item for \tcode{get_public_data_members} (\tcode{get_public_member_functions}), all public data (function, including constructor and destructor) members;
  \item for \tcode{get_accessible_data_members} (\tcode{get_accessible_member_functions}), all data (function, including constructor and destructor) members that are accessible from the context of the invocation of \tcode{reflexpr} which (directly or indirectly) generated \tcode{T}.
\begin{example}\begin{codeblock}
class X {
   int a;

   friend struct Y;
};

struct Y {
  using X_t = reflexpr(X);
};

using X_mem_t = get_accessible_data_members_t<Y::X_t>;
static_assert(get_size_v<X_mem_t> == 1, ""); // passes.
\end{codeblock}\end{example}
\end{itemize}

\pnum
The order of the elements in the \tcode{ObjectSequence} is the order of the declaration of the members in the class reflected by \tcode{T}.

\pnum
\remarks
The program is ill-formed if \tcode{T} reflects a closure type.

\end{itemdescr}

\begin{itemdecl}
template <Record T> struct get_constructors;
template <Record T> struct get_operators;
\end{itemdecl}
\begin{itemdescr}
\pnum
All specializations of these templates shall meet the \tcode{TransformationTrait} requirements (\cxxref{meta.rqmts}). The nested type named \tcode{type} designates a meta-object type satisfying \tcode{ObjectSequence}, containing elements which satisfy \tcode{RecordMember} and reflect the following subset of non-template function members that are either declared in the class reflected by \tcode{T} or that are introduced by a using-declaration in function members of the class reflected by \tcode{T}:
\begin{itemize}
   \item for \tcode{get_constructors}, all constructors.
   \item for \tcode{get_operators}, all conversion functions (\cxxref{class.conv.fct}) and operator functions (\cxxref{over.oper}).
\end{itemize}

\pnum
The order of the elements in the \tcode{ObjectSequence} is the order of the declaration of the members in the class reflected by \tcode{T}.

\pnum
\remarks
The program is ill-formed if \tcode{T} reflects a closure type.
\end{itemdescr}

\begin{itemdecl}
template <Record T> struct get_destructor;
\end{itemdecl}
\begin{itemdescr}
\pnum
All specializations of \tcode{get_destructor<T>} shall meet the \tcode{TransformationTrait} requirements (\cxxref{meta.rqmts}). The nested type named \tcode{type} designates a \tcode{Destructor} type that reflects the destructor declared in the class reflected by \tcode{T}.

\pnum
\remarks
The program is ill-formed if \tcode{T} reflects a closure type.
\end{itemdescr}

\begin{itemdecl}
template <Record T> struct get_public_member_types;
template <Record T> struct get_accessible_member_types;
template <Record T> struct get_member_types;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of these templates shall meet the \tcode{TransformationTrait} requirements (\cxxref{meta.rqmts}). The nested type named \tcode{type} designates a meta-object type satisfying \tcode{ObjectSequence}, containing elements which satisfy \tcode{Type} and reflect the following subset of non-template types that are either declared in the class reflected by \tcode{T} or that are introduced by a using declaration in the class reflected by \tcode{T}:
\begin{itemize}
  \item for \tcode{get_public_member_types}, all public nested class types, enum types, or member typedefs;
  \item for \tcode{get_accessible_member_types}, all nested class types, enum types, or member typedefs that are accessible from the scope of the invocation of \tcode{reflexpr} which (directly or indirectly) generated \tcode{T};
  \item for \tcode{get_member_types}, all nested class types, enum types, or member typedefs.
\end{itemize}

\pnum
The order of the elements in the \tcode{ObjectSequence} is the order of the first declaration of the types in the class reflected by \tcode{T}.

\pnum
\remarks
The program is ill-formed if \tcode{T} reflects a closure type.
\end{itemdescr}

\begin{itemdecl}
template <Class T> struct get_public_base_classes;
template <Class T> struct get_accessible_base_classes;
template <Class T> struct get_base_classes;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of these templates shall meet the \tcode{TransformationTrait} requirements (\cxxref{meta.rqmts}). The nested type named \tcode{type} designates a meta-object type satisfying \tcode{ObjectSequence}, containing elements which satisfy \tcode{Base} and reflect the following subset of base classes of the class reflected by \tcode{T}:
\begin{itemize}
  \item for \tcode{get_public_base_classes}, all public direct base classes;
  \item for \tcode{get_accessible_base_classes}, all direct base classes whose public members are accessible from the scope of the invocation of \tcode{reflexpr} which (directly or indirectly) generated \tcode{T};
  \item for \tcode{get_base_classes}, all direct base classes.
\end{itemize}

\pnum
The order of the elements in the \tcode{ObjectSequence} is the order of the declaration of the base classes in the class reflected by \tcode{T}.

\pnum
\remarks
The program is ill-formed if \tcode{T} reflects a closure type.
\end{itemdescr}

\begin{itemdecl}
template <Class T> struct is_final<T>;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of \tcode{is_final<T>} shall meet the \tcode{UnaryTypeTrait} requirements (\cxxref{meta.rqmts}). If \tcode{T} reflects a class that is marked with the \grammarterm{class-virt-specifier} \tcode{final}, the base characteristic of the respective template specialization is \tcode{true_type}, otherwise it is \tcode{false_type}.
\end{itemdescr}

\end{std.txt}

\rSec3[reflect.ops.enum]{Enum operations}

\begin{std.txt}\color{addclr}

\begin{itemdecl}
template <Enum T> struct is_scoped_enum;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of \tcode{is_scoped_enum<T>} shall meet the \tcode{UnaryTypeTrait} requirements (\cxxref{meta.rqmts}). If \tcode{T} reflects a scoped enumeration, the base characteristic of the respective template specialization is \tcode{true_type}, otherwise it is \tcode{false_type}.

\end{itemdescr}

\begin{itemdecl}
template <Enum T> struct get_enumerators;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of \tcode{get_enumerators<T>} shall meet the \tcode{TransformationTrait} requirements (\cxxref{meta.rqmts}). The nested type named \tcode{type} designates a meta-object type satisfying \tcode{ObjectSequence}, containing elements which satisfy \tcode{Enumerator} and reflect the enumerators of the enumeration type reflected by \tcode{T}.

\pnum
\remarks
A specialization of this template with a meta-object type that is reflecting an incomplete type renders the program ill-formed.
      Such errors are not in the immediate context (\cxxref{temp.deduct}).
\end{itemdescr}

\begin{itemdecl}
template <Enum T> struct get_underlying_type;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of \tcode{get_underlying_type<T>} shall meet the
\tcode{TransformationTrait} requirements (\cxxref{meta.rqmts}). The nested type named
\tcode{type} designates a meta-object type that reflects the underlying type
(\cxxref{dcl.enum}) of the enumeration reflected by \tcode{T}.

\pnum
\remarks
A specialization of this template with a meta-object type that is reflecting an incomplete type renders the program ill-formed.
      Such errors are not in the immediate context (\cxxref{temp.deduct}).
\end{itemdescr}
\end{std.txt}

\rSec3[reflect.ops.value]{Value operations}

\begin{std.txt}\color{addclr}

\begin{itemdecl}
template <Constant T> struct get_constant;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of \tcode{get_constant<T>} shall meet the \tcode{UnaryTypeTrait} requirements (\cxxref{meta.rqmts}). The type and value of the static data member named \tcode{value} are those of the constant expression of the constant reflected by \tcode{T}.

\end{itemdescr}

\begin{itemdecl}
template <Variable T> struct is_constexpr<T>;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of this partial template specialization shall meet the \tcode{UnaryTypeTrait} requirements (\cxxref{meta.rqmts}). If \tcode{T} reflects a variable declared with the \grammarterm{decl-specifier} \tcode{constexpr}, the base characteristic of the respective template specialization is \tcode{true_type}, otherwise it is \tcode{false_type}.
\end{itemdescr}

\begin{itemdecl}
template <Variable T> struct is_static<T>;
template <Variable T> struct is_thread_local;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of \tcode{is_static<T>} and \tcode{is_thread_local<T>} shall meet the \tcode{UnaryTypeTrait} requirements (\cxxref{meta.rqmts}). If \tcode{T} reflects a variable with static (for \tcode{is_static}) or thread (for \tcode{is_thread_local}) storage duration, the base characteristic of the respective template specialization is \tcode{true_type}, otherwise it is \tcode{false_type}.
\end{itemdescr}

\begin{itemdecl}
template <Variable T> struct get_pointer<T>;
\end{itemdecl}

\begin{itemdescr}
\pnum
If \tcode{T} reflects a reference with static storage duration, and the reference has no prior initialization or has not been initialized with an object of static storage duration, the specialization of \tcode{get_pointer<T>} has no member named \tcode{type}. Otherwise, the specialization
of \tcode{get_pointer<T>} shall meet the \tcode{UnaryTypeTrait} requirements (\cxxref{meta.rqmts}), with a static data member named \tcode{value} of type \tcode{X} and value \tcode{x}, where
\begin{itemize}
  \item for variables with static storage duration: \tcode{X} is \tcode{add_pointer<Y>}, where \tcode{Y} is the type of the variable reflected by \tcode{T}, and \tcode{x} is the address of that variable; otherwise,
  \item \tcode{X} is the pointer-to-member type of the non-static data member reflected by \tcode{T} and \tcode{x} a pointer to that member.
\end{itemize}
\end{itemdescr}
\end{std.txt}

\rSec3[reflect.ops.derived]{Base operations}

\begin{std.txt}\color{addclr}
A specialization of any of these templates with a meta-object type that is reflecting an incomplete type renders the program ill-formed.
      Such errors are not in the immediate context (\cxxref{temp.deduct}).

\begin{itemdecl}
template <Base T> struct get_class;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of \tcode{get_class<T>} shall meet the \tcode{TransformationTrait} requirements (\cxxref{meta.rqmts}). The nested type named \tcode{type} designates \tcode{reflexpr(\emph{X})}, where \tcode{\emph{X}} is the base class (without retaining possible \tcode{Alias} properties, see \ref{reflect.concepts.alias}) reflected by \tcode{T}.
\end{itemdescr}

\begin{itemdecl}
template <Base T> struct is_virtual<T>;
template <Base T> struct is_public<T>;
template <Base T> struct is_protected<T>;
template <Base T> struct is_private<T>;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of these partial template specializations shall meet the \tcode{UnaryTypeTrait} requirements (\cxxref{meta.rqmts}). If \tcode{T} reflects a direct base class with the \tcode{virtual} specifier (for \tcode{is_virtual}), with the \tcode{public} specifier or with an assumed (see \cxxref{class.access.base}) \tcode{public} specifier (for \tcode{is_public}), with the \tcode{protected} specifier (for \tcode{is_protected}), or with the \tcode{private} specifier or with an assumed \tcode{private} specifier (for \tcode{is_private}), then the base characteristic of the respective template specialization is \tcode{true_type}, otherwise it is \tcode{false_type}.
\end{itemdescr}
\end{std.txt}

\rSec3[reflect.ops.namespace]{Namespace operations}

\begin{std.txt}\color{addclr}

\begin{itemdecl}
template <Namespace T> struct is_inline<T>;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of \tcode{is_inline<T>} shall meet the \tcode{UnaryTypeTrait} requirements (\cxxref{meta.rqmts}). If \tcode{T} reflects an inline namespace, the base characteristic of the template specialization is \tcode{true_type}, otherwise it is \tcode{false_type}.

\end{itemdescr}
\end{std.txt}

\rSec3[reflect.ops.fctparam]{FunctionParameter operations }
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <FunctionParameter T> struct has_default_argument;
\end{itemdecl}
\begin{itemdescr}
\pnum
All specializations of this template shall meet the \tcode{UnaryTypeTrait}
requirements (\cxxref{meta.rqmts}). If \tcode{T} reflects a parameter with a default
argument, the base characteristic of \tcode{has_default_argument<T>} is
\tcode{true_type}, otherwise it is \tcode{false_type}.

\pnum
\remarks
Subsequent specializations of \tcode{has_default_argument<T>} on the same
reflected function parameter can render the program ill-formed, no diagnostic
required (\ref{reflect.ops}).
\end{itemdescr}
\end{std.txt}


\rSec3[reflect.ops.callable]{Callable operations}
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <Callable T> struct get_parameters;
\end{itemdecl}
\begin{itemdescr}
\pnum
      All specializations of this template shall meet the \tcode{TransformationTrait} requirements (\cxxref{meta.rqmts}). The nested type named \tcode{type} designates a meta-object type satisfying \tcode{ObjectSequence}, containing elements which satisfy \tcode{FunctionParameter} and reflect the parameters of the function reflected by \tcode{T}.
      If that function's \grammarterm{parameter-declaration-clause} (\cxxref{dcl.fct}) terminates with an ellipsis, the \tcode{ObjectSequence} does not contain any additional elements reflecting that. The \tcode{is_vararg_v<Callable>} trait can be used to determine if the terminating ellipsis is in its parameter list.
\end{itemdescr}

\begin{itemdecl}
template <Callable T> struct is_vararg;
template <Callable T> struct is_constexpr<T>;
template <Callable T> struct is_noexcept;
template <Callable T> struct is_inline<T>;
template <Callable T> struct is_deleted;
\end{itemdecl}
\begin{itemdescr}
\pnum
      All specializations of these templates and partial template specializations shall meet the
      \tcode{UnaryTypeTrait} requirements (\cxxref{meta.rqmts}).  If their template
      parameter reflects an entity with an ellipsis terminating the
      \grammarterm{parameter-declaration-clause} (\cxxref{dcl.fct}) (for
      \tcode{is_vararg}), or an entity that is (where applicable implicitly or
      explicitly) declared as \tcode{constexpr} (for \tcode{is_constexpr}),
      as \tcode{noexcept} (for \tcode{is_noexcept}), as an inline function
      (\cxxref{dcl.fct.spec}) (for \tcode{is_inline}), or as deleted (for
      \tcode{is_deleted}), the base characteristic of the respective template
      specialization is \tcode{true_type}, otherwise it is \tcode{false_type}.

\pnum
\remarks
Subsequent specializations of \tcode{is_inline<T>} on the same reflected
function can render the program ill-formed, no diagnostic required
(\ref{reflect.ops}).
\end{itemdescr}
\end{std.txt}

\rSec3[reflect.ops.expr.paren]{ParenthesizedExpression operations}
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <ParenthesizedExpression T> struct get_subexpression;
\end{itemdecl}
\begin{itemdescr}
\pnum
      All specializations of \tcode{get_subexpression<T>} shall meet the \tcode{TransformationTrait} requirements (\cxxref{meta.rqmts}). The nested type named \tcode{type} is the \tcode{Expression} type reflecting the expression \tcode{E} of the parenthesized expression \tcode{(E)} reflected by \tcode{T}. 
\end{itemdescr}
\end{std.txt}

\rSec3[reflect.ops.expr.fctcall]{FunctionCallExpression operations}
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <FunctionCallExpression T> struct get_callable;
\end{itemdecl}
\begin{itemdescr}
\pnum
      All specializations of \tcode{get_callable<T>} shall meet the \tcode{TransformationTrait} requirements (\cxxref{meta.rqmts}). The nested type named \tcode{type} is the \tcode{Callable} type reflecting the function invoked by the \grammarterm{function-call-expression} which is reflected by \tcode{T}.
\end{itemdescr}
\end{std.txt}


\rSec3[reflect.ops.expr.fcttypeconv]{FunctionalTypeConversion operations}
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <FunctionalTypeConversion T> struct get_constructor;
\end{itemdecl}
\begin{itemdescr}
\pnum
			All specializations of \tcode{get_constructor<T>} shall meet the \tcode{TransformationTrait} requirements (\cxxref{meta.rqmts}). For a \grammarterm{functional-type-conv-expression} reflected by \tcode{T}, let \tcode{S} be the type specified by the type conversion (\cxxref{expr.type.conv}). If a constructor is used for the initialization of \tcode{S}, the type \tcode{get_constructor<T>::type} is the \tcode{Constructor} reflecting that constructor; otherwise, \tcode{get_constructor<T>} has no member named \tcode{type}.
      \begin{note} For instance fundamental types (\cxxref{basic.fundamental}) do not have constructors. \end{note}
\end{itemdescr}
\end{std.txt}

\rSec3[reflect.ops.fct]{Function operations}
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <Function T> struct get_pointer<T>;
\end{itemdecl}
\begin{itemdescr}
\pnum
      All specializations of \tcode{get_pointer<T>} shall meet the \tcode{UnaryTypeTrait} requirements (\cxxref{meta.rqmts}), with a static data member named \tcode{value} of type \tcode{X} and value \tcode{x}, where
         \begin{itemize}
           \item for non-static member functions, \tcode{X} is the pointer-to-member-function type of the member function reflected by \tcode{T} and \tcode{x} a pointer to the member function; otherwise,
           \item \tcode{X} is \tcode{add_pointer<Y>}, where \tcode{Y} is the type of the function reflected by \tcode{T} and \tcode{x} is the address of that function. 
         \end{itemize}
\end{itemdescr}
\end{std.txt}

\rSec3[reflect.ops.memfct]{MemberFunction operations}
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <MemberFunction T> struct is_static<T>;
template <MemberFunction T> struct is_const;
template <MemberFunction T> struct is_volatile;
template <MemberFunction T> struct has_lvalueref_qualifier;
template <MemberFunction T> struct has_rvalueref_qualifier;
template <MemberFunction T> struct is_virtual<T>;
template <MemberFunction T> struct is_pure_virtual<T>;
template <MemberFunction T> struct is_override;
template <MemberFunction T> struct is_final<T>;
\end{itemdecl}
\begin{itemdescr}
\pnum
      All specializations of these templates and partial template specializations shall meet the
      \tcode{UnaryTypeTrait} requirements (\cxxref{meta.rqmts}). If their template
      parameter reflects a member function that is \tcode{static} (for
      \tcode{is_static}), \tcode{const} (for \tcode{is_const}),
      \tcode{volatile} (for \tcode{is_volatile}), declared with a
      \grammarterm{ref-qualifier} \tcode{\&} (for
      \tcode{has_lvalueref_qualifier}) or \tcode{\&\&} (for
      \tcode{has_rvalueref_qualifier}), implicitly or explicitly \tcode{virtual}
      (for \tcode{is_virtual}), pure virtual (for \tcode{is_pure_virtual}), or
      overrides a member function of a base class (for \tcode{is_override}) or \tcode{final}
      (for \tcode{is_final}), the base characteristic of the respective
      template specialization is \tcode{true_type}, otherwise it is
      \tcode{false_type}.
\end{itemdescr}
\end{std.txt}


\rSec3[reflect.ops.specialfct]{SpecialMemberFunction operations}
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <SpecialMemberFunction T> struct is_implicitly_declared;
template <SpecialMemberFunction T> struct is_defaulted;
\end{itemdecl}
\begin{itemdescr}
\pnum
      All specializations of these templates shall meet the
      \tcode{UnaryTypeTrait} requirements (\cxxref{meta.rqmts}). If their template
      parameter reflects a special member function that is implicitly declared
      (for \tcode{is_implicitly_declared}) or that is defaulted in its first
      declaration (for \tcode{is_defaulted}), the base characteristic of the
      respective template specialization is \tcode{true_type}, otherwise it is
      \tcode{false_type}.
\end{itemdescr}
\end{std.txt}

\rSec3[reflect.ops.ctor]{Constructor operations}
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <Constructor T> struct is_explicit<T>;
\end{itemdecl}
\begin{itemdescr}
\pnum
      All specializations of this partial template specialization shall meet the
      \tcode{UnaryTypeTrait} requirements (\cxxref{meta.rqmts}). If the template
      parameter reflects an explicit constructor, the base characteristic of
      the respective template specialization is \tcode{true_type}, otherwise it
      is \tcode{false_type}.
\end{itemdescr}
\end{std.txt}


\rSec3[reflect.ops.dtor]{Destructor operations}
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <Destructor T> struct is_virtual<T>;
template <Destructor T> struct is_pure_virtual<T>;
\end{itemdecl}
\begin{itemdescr}
\pnum
      All specializations of these partial template specializations shall meet the
      \tcode{UnaryTypeTrait} requirements (\cxxref{meta.rqmts}). If the template
      parameter reflects a virtual (for \tcode{is_virtual}) or pure virtual
      (for \tcode{is_pure_virtual}) destructor, the base characteristic of the
      respective template specialization is \tcode{true_type}, otherwise it is
      \tcode{false_type}.
\end{itemdescr}
\end{std.txt}


\rSec3[reflect.ops.convfct]{ConversionOperator operations}
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <ConversionOperator T> struct is_explicit<T>;
\end{itemdecl}
\begin{itemdescr}
\pnum
      All specializations of \tcode{is_explicit<T>} shall meet the
      \tcode{UnaryTypeTrait} requirements (\cxxref{meta.rqmts}). If the template
      parameter reflects an explicit conversion function, the base
      characteristic of the respective template specialization is
      \tcode{true_type}, otherwise it is \tcode{false_type}.
\end{itemdescr}
\end{std.txt}


\rSec3[reflect.ops.lambda]{Lambda operations}
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <Lambda T> struct get_captures;
\end{itemdecl}
\begin{itemdescr}
\pnum
      All specializations of \tcode{get_captures<T>} shall meet the
      \tcode{TransformationTrait} requirements (\cxxref{meta.rqmts}). The nested type
      named \tcode{type} designates a meta-object type satisfying \tcode{ObjectSequence}, containing elements which satisfy
      \tcode{LambdaCapture} and reflect the captures of the closure
      object reflected by \tcode{T}.  The elements are in order of appearance
      in the \grammarterm{lambda-capture}; captures captured because of a
      \grammarterm{capture-default} have no defined order among the default
      captures.
\end{itemdescr}

\begin{itemdecl}
template <Lambda T> struct uses_default_copy_capture;
template <Lambda T> struct uses_default_reference_capture;
\end{itemdecl}
\begin{itemdescr}
\pnum
      All specializations of these templates shall meet the
      \tcode{UnaryTypeTrait} requirements (\cxxref{meta.rqmts}). If the template
      parameter reflects a closure object with a \grammarterm{capture-default}
      that is \tcode{=} (for \tcode{uses_default_copy_capture}) or \tcode{\&}
      (for \tcode{uses_default_reference_capture}), the base characteristic of
      the respective template specialization is \tcode{true_type}, otherwise it
      is \tcode{false_type}.
\end{itemdescr}

\begin{itemdecl}
template <Lambda T> struct is_call_operator_const;
\end{itemdecl}
\begin{itemdescr}
\pnum
      All specializations of \tcode{is_call_operator_const<T>} shall meet the
      \tcode{UnaryTypeTrait} requirements (\cxxref{meta.rqmts}). If the template
      parameter reflects a closure object with a \tcode{const} function call
      operator, the base characteristic of the respective template
      specialization is \tcode{true_type}, otherwise it is \tcode{false_type}.
\end{itemdescr}
\end{std.txt}


\rSec3[reflect.ops.lambdacapture]{LambdaCapture operations}
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <LambdaCapture T> struct is_explicitly_captured;
\end{itemdecl}
\begin{itemdescr}
\pnum
      All specializations of \tcode{is_explicitly_captured<T>} shall meet the
      \tcode{UnaryTypeTrait} requirements (\cxxref{meta.rqmts}). If the template
      parameter reflects an explicitly captured entity, the base characteristic
      of the respective template specialization is \tcode{true_type}, otherwise
      it is \tcode{false_type}.
\end{itemdescr}

\begin{itemdecl}
template <LambdaCapture T> struct is_init_capture;
\end{itemdecl}
\begin{itemdescr}
\pnum
      All specializations of \tcode{is_init_capture<T>} shall meet the
      \tcode{UnaryTypeTrait} requirements (\cxxref{meta.rqmts}). If the template
      parameter reflects an \grammarterm{init-capture}, the base characteristic
      of the respective template specialization is \tcode{true_type}, otherwise
      it is \tcode{false_type}.
\end{itemdescr}
\end{std.txt}
