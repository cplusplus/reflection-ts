\rSec0[expr]{Expressions}

\setcounter{section}{0}
\rSec1[expr.prim]{Primary expressions}
\setcounter{subsection}{1}
\rSec2[expr.prim.lambda]{Lambda expressions}

\pnum
In C++ [expr.prim.lambda], apply the following change to the second bullet in paragraph \cxxref{expr.prim.lambda.paragraph0}:

\renewcommand{\labelitemi}{---}
\begin{std.txt}
\begin{itemize}
\item names the entity in a potentially-evaluated expression (3.2) where the enclosing full-expression depends on a generic lambda parameter declared within the reaching scope of the \textit{lambda-expression}\removed{.}\added{;} % Note, \textit is used here to avoid the \xspace in \grammarterm
\end{itemize}
\added{where, for the process of this determination, \tcode{reflexpr} operands are not considered to be unevaluated operands}.
\end{std.txt}
\renewcommand{\labelitemi}{---\parabullnum{Bullets1}{\labelsep}}

\pnum
Also apply the following change to paragraph \cxxref{expr.prim.lambda.paragraph1}:

\begin{std.txt}
Every \grammarterm{id-expression} within the \grammarterm{compound-statement} of a \grammarterm{lambda-expression} that is an odr-use~(\ref{basic.def.odr}) of an entity captured by copy\added{, as well as every use of an entity captured by copy in a \grammarterm{reflexpr-operand},} is transformed into an access to the corresponding unnamed data member of the closure type.
\end{std.txt}

\rSec1[expr.post]{Postfix expressions}

\pnum
In C++ [expr.post], apply the following change:

\begin{std.txt}
\begin{bnf}
\nontermdef{postfix-expression}\br
    primary-expression\br
    postfix-expression \terminal{[} expression \terminal{]}\br
    postfix-expression \terminal{[} braced-init-list \terminal{]}\br
    \removed{postfix-expression \terminal{(} \opt{expression-list} \terminal{)}}\br
    \added{function-call-expression}\br
    \removed{simple-type-specifier \terminal{(} \opt{expression-list} \terminal{)}}\br
    \removed{typename-specifier \terminal{(} \opt{expression-list} \terminal{)}}\br
    \removed{simple-type-specifier braced-init-list}\br
    \removed{typename-specifier braced-init-list}\br
    \added{functional-type-conv-expression}\br
    postfix-expression \opt{\terminal{. template}} id-expression\br
    postfix-expression \opt{\terminal{-> template}} id-expression\br
    postfix-expression \terminal{.} pseudo-destructor-name\br
    postfix-expression \terminal{->} pseudo-destructor-name\br
    postfix-expression \terminal{++}\br
    postfix-expression \terminal{-{-}}\br
    \terminal{dynamic_cast <} type-id \terminal{> (} expression \terminal{)}\br
    \terminal{static_cast <} type-id \terminal{> (} expression \terminal{)}\br
    \terminal{reinterpret_cast <} type-id \terminal{> (} expression \terminal{)}\br
    \terminal{const_cast <} type-id \terminal{> (} expression \terminal{)}\br
    \terminal{typeid (} expression \terminal{)}\br
    \terminal{typeid (} type-id \terminal{)}
\end{bnf}

\begin{bnf}
\added{\nontermdef{function-call-expression}}\br
    \added{postfix-expression \terminal{(} \opt{expression-list} \terminal{)}}
\end{bnf}

\begin{bnf}
\added{\nontermdef{functional-type-conv-expression}}\br
    \added{simple-type-specifier \terminal{(} \opt{expression-list} \terminal{)}}\br
    \added{typename-specifier \terminal{(} \opt{expression-list} \terminal{)}}\br
    \added{simple-type-specifier braced-init-list}\br
    \added{typename-specifier braced-init-list}
\end{bnf}

\begin{bnf}
\nontermdef{expression-list}\br
    initializer-list
\end{bnf}
\end{std.txt}

\rSec0[stmt.stmt]{Statements}

ISO/IEC 14882:2020, Clause \the\value{chapter} applies.
